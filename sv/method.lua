local method = {}

method.isVirtual = false
method.virtual = function(self)
	self.isVirtual = true
end
method.prototype = function(self,n,arg,t,rtn)
	local p = '\textern '
	if self.isVirtual then
		p = p..'virtual '
	end
	p = p..t
	if t=='function' then
		p = p..' '..rtn
	end
	p = p..' '..n..' ('..arg..');'
	return p
end
method.body = function(self,cn,mn,arg,t,rtn,block)
	local cnts = {}
	local tf = t
	if t=='function' then
		tf = tf..' '..rtn
	end
	local fullmethod = cn..'::'..mn
	table.insert(cnts,tf..' '..fullmethod..'('..arg..');')
	for _,b in ipairs(block) do
		table.insert(cnts,'\t'..b)
	end
	table.insert(cnts,'end'..t)
	return cnts
end
-- new added here

local fop = require('common.fileop')
method.newPrototype = function(self,fn,t,rtn)
	local p = '\textern '
	if self.isVirtual then
		p = p..'virtual '
	end
	p = p..t
	if t=='function' then
		p = p..' '..rtn
	end
	p = p..' '..fn..';'
	return p
end
method.newBody = function(self,cn,mn,t,rtn,block)
	local cnts = {}
	local tf = t
	if t=='function' then
		tf = tf..' '..rtn
	end
	local fullmethod = cn..'::'..mn
	table.insert(cnts,tf..' '..fullmethod..';')
	for _,b in ipairs(block) do
		table.insert(cnts,'\t'..b)
	end
	table.insert(cnts,'end'..t)
	return cnts
end

-- cline is current line number where the cursor is
-- eline is the end line of the class body where the cursor is
method.deffunc = function(self,rtn,args,cline,cls,eline)
	-- print("get rtn: "..rtn..", func: "..args)
	proto = self:newPrototype(args,'function',rtn)
	-- print("proto: "..proto)
	-- insert prototype
	cnts = {}
	table.insert(cnts,proto)
	fop:insertContents(cnts,cline);
	-- insert body
	exbody = {}
	table.insert(exbody,'// This method is auto generated by cmd:Func')
	cnts = self:newBody(cls,args,'function',rtn,exbody)
	fop:insertContents(cnts,eline+1);
	return
end
method.deftask = function(self,args,cline,cls,eline)
	-- print("get rtn: "..rtn..", func: "..args)
	proto = self:newPrototype(args,'task','')
	-- print("proto: "..proto)
	-- insert prototype
	cnts = {}
	table.insert(cnts,proto)
	fop:insertContents(cnts,cline);
	-- insert body
	exbody = {}
	table.insert(exbody,'// This method is auto generated by cmd:Func')
	cnts = self:newBody(cls,args,'task','',exbody)
	fop:insertContents(cnts,eline+1);
	return
end

method.splitrtns = function(self,arg)
	cnts = {}
	len = string.len(arg)
	for i=0,len-1,1 do
		if string.sub(arg,i,i)==' ' then
			table.insert(cnts,string.sub(arg,0,i-1))
			table.insert(cnts,string.sub(arg,i+1))
			return cnts;
		end
	end
	table.insert(cnts,arg)
	return cnts;
end

-- get the class in which current line is
-- return cls is a table that:
-- cls[1] represents the class name
-- cls[2] represents the endclass line
method.getEnclosedClass = function(self,line)
	cnts = vim.api.nvim_buf_get_lines(0,0,-1,true)
	cls = {}
	for i=line,1,-1 do
		md = string.match(cnts[i],"^class +([%w_]+)")
		if md ~= nil then
			table.insert(cls,md)
		end
	end
	for i,cnt in ipairs(cnts) do
		if i>=line then
			if string.match(cnt,"^endclass") then
				table.insert(cls,i)
			end
		end
	end
	return cls
end
method.defmethod = function(self,t,args)
	local cn = vim.api.nvim_win_get_cursor(0)
	cls = self:getEnclosedClass(cn[1])
	if t=='func' then
		rtns = self:splitrtns(args)
		self:deffunc(rtns[1],rtns[2],cn[1],cls[1],cls[2])
	else
		self:deftask(args,cn[1],cls[1],cls[2])
	end
end
-- reset internal sets
method.reset = function(self)
	self.isVirtual = false
end
-- new added finished


return method
